# 입실 체크 해주세요 !! 💌

# Spring Security 추가 정리
## 정의
- Spring 기반의 애플리케이션 보안(Authentication / Authorization)을 위한 표준 프레임워크. 서블릿 필터(Servlet Filter) 체인을 기반으로 동작하며, 웹 요청에 대한 보안을 체계적으로 처리함. 단순한 로그인 기능 뿐만 아니라, CSRF 공격 방지, 세션 관리, 권한 기반 접근 제어 등 포괄적인 보안 기능을 제공.
## 특징
1. 포괄적 보안 기능 : 인증(Authentication) / 인가(Authorization) 뿐 아니라 일반적인 웹 보안 위협으로부터 애플리케이션을 보호.
2. 유연한 설정 : Java 기반의 설정을 통해 유연하게 보안 정책을 설정할 수 있음(우리가 해야한다는 뜻입니다).
3. 서블릿 필터 기반 : 요청이 컨트롤러에 도달하기 전에 여러 보안 필터를 거치게 하여 선제적인 보안 검사를 수행.
4. SpringBoot와의 통합 : `spring-boot-starter-security`의존성만 추가하면 기본적인 보안 기능이 자동 설정되어 빠르게 적용가능(default 로그인 페이지가 생겼고, password가 콘솔에 찍혔습니다).
## SecurityConfig 
- Spring Security의 보안 구성(Config)을 담당하는 Java 설정 클래스로, 해당 클래스에는 `@Configuration, @EnableWebSecurity` 애너테이션을 추가하여 Spring Security의 웹 보안 설정을 활성화하고 커스터마이징할 수 있습니다.

- 과거에는 `WebSecurityConfigurerAdapter`를 상속 받아서 configure() 메서드를 오버라이딩하는 방식으로 사용했었지만, SpringBoot 3.x 버전부터는 SecurityFilterChain 빈(bean)을 등록하는 방식이 권장됩니다. 현재의 방식은 컴포넌트 기반의 구성으로, 더욱 모듈화되고 유연한 보안 구성이 가능합니다.

### SecurityConfig의 핵심 역할
1. HTTP 요청에 대한 접근 제어 : 특정 URL 패턴에 대해 인증된 사용자만 접근을 허용하거나, 특정 권한(Role)을 가진 사용자만 접근 가능하도록 설정 가능.
2. 인증 방식 설정 : 폼 로그인(Form Login), HTTP Basic 인증, OAuth2 로그인 등 다양한 인증 방식을 설정하고 커스터마이징 가능.
3. 로그아웃 처리 : 로그아웃 URL 및 로그아웃 성공 후 처리 로직을 정의.
4. 비밀번호 암호화 : `PasswordEncoder`를 빈으로 등록하여 사용자의 비밀번호를 안전하게 암호화하고 검증하는 방식을 지정.
5. CSRF, CORS 설정 : CSRF 보호 기능을 활성화하거나 비활성화하고, CORS 정책을 구성합니다.

### SecurityConfig 코드 예시
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
  // 비밀 번호 등록을 위한 PasswordEncoder 빈을 등록
  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCyptPasswordEncoder();
  }

  // Spring Security의 filterChain을 작성할겁니다.
  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
      // 1. 인가(Authorization) 구성
        .authorizeHttpRequests(authorize -> authorize
          .requestMatchers("/users/**").authenticated() // /user/** 경로는 인증된 user만 가능
          .requestMatchers("/manager/**").hasAnyRole("ADMIN", "MANAGER") // /manager/** 경로는 role이 ADMIN이거나 MANAGER인 user만 가능
          .requestMatchers("/admin/**").hasRole("ADMIN") // /admin/** 경로는 role이 ADMIN인 user만 가능
          .anyRequest().permitAll() // 나머지 경로에 대한 요청들은 접근을 허용함.
        )
        // 2. 폼 로그인(Form Login) 구성
        .formLogin(form -> form
          .loginPage("/login")    // 커스텀 로그인 페이지의 URL 지정
          .loginProcessingUrl("/loginProc") // 로그인 처리 URL
          .defaultSucessUrl("/")  // 로그인 성공 시 이동할 default URL
          .permitAll()            // 로그인 페이지는 모든 사용자가 접근 가능
        )
        // 3. 로그아웃 설정
        .logout(logout -> logout
          .logoutUrl("/logout")   // 로그아웃 처리 URL
          .logoutSuccessUrl("/")  // 로그아웃 성공 시 이동할 URL
          .invalidateHttpSession(true)    // 세션 무효화
          .deleteCookies("JSESSIONID")         // 쿠키 삭제
        )
        // 4. CSRF 보호 비활성화(API 서버의 경우)
        .csrf(csrf -> csrf.disable());
  }
}
```
- 이상의 코드의 상세 설명
  1. authorizeHttpRequests : HTTP 요청에 대한 인가 규칙을 구성.
    - requestMatchers() : 특정 URL 패턴을 지정
    - authenticated() : 인증된 사용자만 접근 허용
    - hasAnyRole(), hasRole() : 특정 역할을 가진 사용자만 접근을 허용. Spring Security에서 역할(Role)은 기본적으로 "ROLE_" 접두사가 붙어서 처리됩니다.(예시 : hasRole("ADMIN")은 "ROLE_ADMIN" 역할을 확인한다는 의미입니다)
    - permitAll() : 모든 사용자의 접근을 허용.
    - anyRequest() : 위에서 설정한 규칙 외의 모든 요청을 의미함. _그래서 인가 규칙의 경우 구체적인 경로를 먼저 구성하고, 포괄적인 경로는 나중에 구성해야 합니다._ 
  2. formLogin : 폼 기반 로그인을 설정
    - loginPage() : 기본 제공되는 로그인 페이지 대신 사용할 커스텀 로그인 페이지의 경로를 지정.
    - loginProcessingUrl() : 로그인 폼 데이터를 처리할 URL을 지정. 이 URL에 대한 POST 요청을 Spring Security가 가로채서 인증을 처리함.
    - defaultSuccessUrl() : 로그인 성공 후 사용자를 리디렉션할 기본 페이지 지정.
  3. logout : 로그아웃 관련 설정.
    - logouturl() : 로그아웃을 처리할 URL을 지정.
    - logoutSuccessUrl() : 로그아웃 성공 후 리디렉션 될 페이지를 지정.
    - invalidateHttpSession(true) : 로그아웃 시 HTTP 세션을 무효화.
    - deleteCookies("JSESSIONID") : 로그아웃 시 지정된 쿠키를 삭제.
  4. csrf(csrf -> csrf.disable()) : CSRF 보호 기능을 비활성화. 세션 기반 인증이 아니라 _JWT와 같은 토큰 기반 인증을 사용하는 API 서버의 경우 일반적으로 비활성화_


Java 관련 visual studio code Extension

Code Runner -> Java 프로젝트를 실행시키려면 필요합니다.
Debugger for Java
Extension Pack for Java